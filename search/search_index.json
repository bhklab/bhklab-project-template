{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project Template for BHKLab Projects Project Overview The BHKLab project template aims to provide: Simple project setup with pixi, mkdocs, and basic DMP folder structure Support for reproducible research with proper documentation GitHub integrations and standardized workflow Pre-configured DMP-compliant directories via damply How this works This project uses the copier tool to maintain a standardized project template that follows the general structure of BHKLab repositories. Copier facilitates the management of project templates by using jinja2 templating for file/directory names and content in the template. Issues Please report any issues with the template to the bhklab/bhklab-project-template . Contributors Jermiah Joseph (@jjjermiah) Katy Scott (@strixy16)","title":"Home"},{"location":"#project-template-for-bhklab-projects","text":"","title":"Project Template for BHKLab Projects"},{"location":"#project-overview","text":"The BHKLab project template aims to provide: Simple project setup with pixi, mkdocs, and basic DMP folder structure Support for reproducible research with proper documentation GitHub integrations and standardized workflow Pre-configured DMP-compliant directories via damply","title":"Project Overview"},{"location":"#how-this-works","text":"This project uses the copier tool to maintain a standardized project template that follows the general structure of BHKLab repositories. Copier facilitates the management of project templates by using jinja2 templating for file/directory names and content in the template.","title":"How this works"},{"location":"#issues","text":"Please report any issues with the template to the bhklab/bhklab-project-template .","title":"Issues"},{"location":"#contributors","text":"Jermiah Joseph (@jjjermiah) Katy Scott (@strixy16)","title":"Contributors"},{"location":"development/","text":"Development & Contribution Guide This project uses the copier tool . If you want to contribute to the project template, please take the time to read the copier documentation on how projects are configured and how to use it. How projects are created from templates For the bhklab-project-template , the project is created not by using the copier command directly, but rather via the the python API that is exposed by the copier package. This is done to allow for more flexibility and customization of the project creation process. You can find the code that creates the project in the src/bhklab_project_template/__init__.py . We wrap the API in a click command line interface. I chose this route to make it super simple to get started and to remove the friction in the experience of creating a new project. Contributing to the project template The project template is made up of the following: the copier.yml which defines the questions to ask when creating a new project, and saves the answers to be used by copier to fill in the template files. the TEMPLATE directory which contains the files that will be copied to the new project. The files in this directory are templated using the Jinja2 templating engine and the answers provided in the copier.yml file. the src/bhklab_project_template directory which contains the code that implements the project template. the copier-settings.yml which is just an extension of the copier.yml file via the include feature of copier . This file defines some constant variables used in the workflow, and more importantly, it defines the copier tasks that are run after the project is created. The default approach to using the bhklab-project-template is to use the pixi exec bhklab-project-template command, which is a neat quick wrapper around the bhklab-project-template 's CLI entry point. However, if you make a change to the bhklab-project-template package, you need to go through some extra steps to make sure that the changes are propagated to the users. 1. Make sure the changes are pushed to the main branch & release-please PR is merged After you make changes to the project template, release-please will create a pull request to update the version of the bhklab-project-template package. Only updates pypi package version The release-please PR will only update the version of the bhklab-project-template package in the pyproject.toml file, and push to PyPi via the GitHub Actions workflow. It will not update the version of the bhklab-project-template package in conda-forge . Updating the conda-forge feedstock After 1-3 hours of the release-please PR being merged, and the new version being available on PyPi , the conda-forge feedstock repo should have a PR created by the conda-forge-bot that updates the version (i.e the v0.11.0 PR ). There maintainers defined in the recipe.yaml file, who are responsible for reviewing and merging the PR. If you are a maintainer, make sure all the checks are passing, and then merge the PR. This will update the conda-forge feedstock and trigger a new build of the bhklab-project-template package on conda-forge . The version on conda-forge will be updated within a few hours after the PR is merged. Alternatively , you can also manually trigger a new build, by creating your own PR and updating the version AND sha256 of the bhklab-project-template (see the above PR for an example). This is useful if you want to update the conda-forge feedstock immediately after the release-please PR is merged. Contributing damply and the DamplyDirs utility The DamplyDirs utility is provided via the damply package, and is already included in the project template's pixi.toml file If there are any issues or features that you would like to see in the damply package, please open an issue or a pull request in the bhklab/damply repository","title":"Development"},{"location":"development/#development-contribution-guide","text":"This project uses the copier tool . If you want to contribute to the project template, please take the time to read the copier documentation on how projects are configured and how to use it.","title":"Development &amp; Contribution Guide"},{"location":"development/#how-projects-are-created-from-templates","text":"For the bhklab-project-template , the project is created not by using the copier command directly, but rather via the the python API that is exposed by the copier package. This is done to allow for more flexibility and customization of the project creation process. You can find the code that creates the project in the src/bhklab_project_template/__init__.py . We wrap the API in a click command line interface. I chose this route to make it super simple to get started and to remove the friction in the experience of creating a new project.","title":"How projects are created from templates"},{"location":"development/#contributing-to-the-project-template","text":"The project template is made up of the following: the copier.yml which defines the questions to ask when creating a new project, and saves the answers to be used by copier to fill in the template files. the TEMPLATE directory which contains the files that will be copied to the new project. The files in this directory are templated using the Jinja2 templating engine and the answers provided in the copier.yml file. the src/bhklab_project_template directory which contains the code that implements the project template. the copier-settings.yml which is just an extension of the copier.yml file via the include feature of copier . This file defines some constant variables used in the workflow, and more importantly, it defines the copier tasks that are run after the project is created. The default approach to using the bhklab-project-template is to use the pixi exec bhklab-project-template command, which is a neat quick wrapper around the bhklab-project-template 's CLI entry point. However, if you make a change to the bhklab-project-template package, you need to go through some extra steps to make sure that the changes are propagated to the users.","title":"Contributing to the project template"},{"location":"development/#1-make-sure-the-changes-are-pushed-to-the-main-branch-release-please-pr-is-merged","text":"After you make changes to the project template, release-please will create a pull request to update the version of the bhklab-project-template package. Only updates pypi package version The release-please PR will only update the version of the bhklab-project-template package in the pyproject.toml file, and push to PyPi via the GitHub Actions workflow. It will not update the version of the bhklab-project-template package in conda-forge .","title":"1. Make sure the changes are pushed to the main branch &amp; release-please PR is merged"},{"location":"development/#updating-the-conda-forge-feedstock","text":"After 1-3 hours of the release-please PR being merged, and the new version being available on PyPi , the conda-forge feedstock repo should have a PR created by the conda-forge-bot that updates the version (i.e the v0.11.0 PR ). There maintainers defined in the recipe.yaml file, who are responsible for reviewing and merging the PR. If you are a maintainer, make sure all the checks are passing, and then merge the PR. This will update the conda-forge feedstock and trigger a new build of the bhklab-project-template package on conda-forge . The version on conda-forge will be updated within a few hours after the PR is merged. Alternatively , you can also manually trigger a new build, by creating your own PR and updating the version AND sha256 of the bhklab-project-template (see the above PR for an example). This is useful if you want to update the conda-forge feedstock immediately after the release-please PR is merged.","title":"Updating the conda-forge feedstock"},{"location":"development/#contributing-damply-and-the-damplydirs-utility","text":"The DamplyDirs utility is provided via the damply package, and is already included in the project template's pixi.toml file If there are any issues or features that you would like to see in the damply package, please open an issue or a pull request in the bhklab/damply repository","title":"Contributing damply and the DamplyDirs utility"},{"location":"dmp_directories/","text":"Working with DMP Directories Over the years, we have developed a standardized directory structure via the data management plan (DMP) in our projects. This structure is designed to: Facilitate reproducible research Provide a clear organization for data, code, and documentation Support collaboration and data sharing Promote familiarity and ease of use across projects Understanding DMP Directories is mandatory in the BHKLab This page is just a brief overview of the DMP directory structure. For a comprehensive overview, please take the time to read and understand the damply documentation . The standardized DMP directory structure is implemented via the damply package, which provides tools and conventions for organizing project files in accordance with DMP guidelines. DMP reproducibility litmus test If you are unsure whether your project is DMP-reproducible, ask yourself the following questions: If I had no prior knowledge of the data used in this project, does the documentation provide enough information to understand the data, its sources, and how to obtain it? If I were a new collaborator, would I be able to understand the code and documentation I need to understand and reproduce the project? If I were to delete all the procdata and results directories, could I reproduce the results with just the rawdata and workflow content? DMP Directory Structure As of writing, the recommended directory structure is as follows: project_root/ \u251c\u2500\u2500 config/ # Configuration files \u251c\u2500\u2500 data/ # All data in one parent directory \u2502 \u251c\u2500\u2500 procdata/ # Processed/intermediate data \u2502 \u251c\u2500\u2500 rawdata/ # Raw input data \u2502 \u2514\u2500\u2500 results/ # Analysis outputs \u251c\u2500\u2500 logs/ # Log files \u251c\u2500\u2500 metadata/ # Dataset descriptions \u2514\u2500\u2500 workflow/ # Code organization \u251c\u2500\u2500 notebooks/ # Jupyter notebooks \u2514\u2500\u2500 scripts/ # Analysis scripts DamplyDirs Overview Assuming the above directory structure, the damply package provides a simple way to access these directories via the DamplyDirs class. This class takes advantage of the following environment variables that are defined in the template's pixi.toml file: [activation] # convenient variables which can be used in scripts env . CONFIG = \"${PIXI_PROJECT_ROOT}/config\" env . METADATA = \"${PIXI_PROJECT_ROOT}/metadata\" env . LOGS = \"${PIXI_PROJECT_ROOT}/logs\" env . RAWDATA = \"${PIXI_PROJECT_ROOT}/data/rawdata\" env . PROCDATA = \"${PIXI_PROJECT_ROOT}/data/procdata\" env . RESULTS = \"${PIXI_PROJECT_ROOT}/data/results\" env . SCRIPTS = \"${PIXI_PROJECT_ROOT}/workflow/scripts\" This allows you to programmatically access the directories in your project without hardcoding paths, making your code more portable and easier to maintain. Example Usage Here is an example of how to use the DamplyDirs class in your project: from damply import dirs fastq_file = dirs . RAWDATA / \"fastq\" / \"sample_1.fq.gz\" print ( f \"Processing FASTQ file: { fastq_file } \" ) # Processing FASTQ file: /home/bhkuser/proejcts/data/rawdata/fastq/sample_1.fq.gz A full comprehensive walkthrough of the DamplyDirs utility can be found in the damply documentation .","title":"DMP Directories"},{"location":"dmp_directories/#working-with-dmp-directories","text":"Over the years, we have developed a standardized directory structure via the data management plan (DMP) in our projects. This structure is designed to: Facilitate reproducible research Provide a clear organization for data, code, and documentation Support collaboration and data sharing Promote familiarity and ease of use across projects Understanding DMP Directories is mandatory in the BHKLab This page is just a brief overview of the DMP directory structure. For a comprehensive overview, please take the time to read and understand the damply documentation . The standardized DMP directory structure is implemented via the damply package, which provides tools and conventions for organizing project files in accordance with DMP guidelines. DMP reproducibility litmus test If you are unsure whether your project is DMP-reproducible, ask yourself the following questions: If I had no prior knowledge of the data used in this project, does the documentation provide enough information to understand the data, its sources, and how to obtain it? If I were a new collaborator, would I be able to understand the code and documentation I need to understand and reproduce the project? If I were to delete all the procdata and results directories, could I reproduce the results with just the rawdata and workflow content?","title":"Working with DMP Directories"},{"location":"dmp_directories/#dmp-directory-structure","text":"As of writing, the recommended directory structure is as follows: project_root/ \u251c\u2500\u2500 config/ # Configuration files \u251c\u2500\u2500 data/ # All data in one parent directory \u2502 \u251c\u2500\u2500 procdata/ # Processed/intermediate data \u2502 \u251c\u2500\u2500 rawdata/ # Raw input data \u2502 \u2514\u2500\u2500 results/ # Analysis outputs \u251c\u2500\u2500 logs/ # Log files \u251c\u2500\u2500 metadata/ # Dataset descriptions \u2514\u2500\u2500 workflow/ # Code organization \u251c\u2500\u2500 notebooks/ # Jupyter notebooks \u2514\u2500\u2500 scripts/ # Analysis scripts","title":"DMP Directory Structure"},{"location":"dmp_directories/#damplydirs-overview","text":"Assuming the above directory structure, the damply package provides a simple way to access these directories via the DamplyDirs class. This class takes advantage of the following environment variables that are defined in the template's pixi.toml file: [activation] # convenient variables which can be used in scripts env . CONFIG = \"${PIXI_PROJECT_ROOT}/config\" env . METADATA = \"${PIXI_PROJECT_ROOT}/metadata\" env . LOGS = \"${PIXI_PROJECT_ROOT}/logs\" env . RAWDATA = \"${PIXI_PROJECT_ROOT}/data/rawdata\" env . PROCDATA = \"${PIXI_PROJECT_ROOT}/data/procdata\" env . RESULTS = \"${PIXI_PROJECT_ROOT}/data/results\" env . SCRIPTS = \"${PIXI_PROJECT_ROOT}/workflow/scripts\" This allows you to programmatically access the directories in your project without hardcoding paths, making your code more portable and easier to maintain.","title":"DamplyDirs Overview"},{"location":"dmp_directories/#example-usage","text":"Here is an example of how to use the DamplyDirs class in your project: from damply import dirs fastq_file = dirs . RAWDATA / \"fastq\" / \"sample_1.fq.gz\" print ( f \"Processing FASTQ file: { fastq_file } \" ) # Processing FASTQ file: /home/bhkuser/proejcts/data/rawdata/fastq/sample_1.fq.gz A full comprehensive walkthrough of the DamplyDirs utility can be found in the damply documentation .","title":"Example Usage"},{"location":"gitignore/","text":"Understanding the .gitignore File What and why? The .gitignore file tells Git which files and folders to ignore when tracking changes. Think of it as keeping the party clean by not letting in the uninvited guests (like temporary files, build artifacts, and system-specific files). Our template comes with two .gitignore files: root: TEMPLATE/.gitignore crafted to work with both Python and R development workflows. It's organized into logical sections to make it easy to understand and maintain. data: TEMPLATE/data/.gitignore specifically designed to ignore files in the data directory pre-configured to ignore everything except the README.md files, to prevent users from accidentally rawdata files. Why shouldn't I commit my data files? Answer Large files bloat the repo: Every clone/download pulls the whole history, so a single 500\u202fMB dataset balloons to gigabytes after a few updates. Git is text\u2011oriented: Binary data can\u2019t be delta\u2011compressed well, so each revision is stored almost in full, slowing every operation. Privacy!: Patient or proprietary data in a public repo is dangerous and can lead to Data Use Agreements being violated. Reproducibility best practice: Keep code in Git and store immutable data elsewhere (e.g. Zenodo, FigShare) so others can fetch the exact snapshot you used AND use it across different projects. Backup strategy separation: Repos are for source; archives belong in object storage, not in version control. CI/CD efficiency: Smaller repositories mean faster pipelines and lower bandwidth costs for every contributor. What's inside the main .gitignore file? The .gitignore file is organized into these major sections: Operating System files - Keeps those pesky .DS_Store files (macOS), Thumbs.db (Windows), and other OS-specific clutter out of your repository Python related files - Ignores bytecode, package builds, and other Python-specific temporary files R related files - Skips R history, session data, and package build files IDE/Editor files - Prevents editor configs from PyCharm, VS Code, and others from being shared Dependency Management - Handles ignoring appropriate files from tools like poetry, pipenv, and pdm Build/Test artifacts - Keeps build directories and test results from cluttering your repo Documentation builds - Ignores generated documentation that should be built on-demand Project-specific entries - A section reserved for your specific project needs Why is this important? A well-configured .gitignore file: Keeps your repository clean - No more accidental commits of temporary files Reduces conflicts - Prevents system-specific files from causing merge headaches Improves performance - Git works faster when it doesn't have to track thousands of irrelevant files Maintains security - Prevents accidental commits of sensitive information (like environment files) Tip If you find yourself repeatedly using git add -f to force-add ignored files, that might be a sign you need to adjust your .gitignore file. Handle with care The .gitignore file in this template has been carefully optimized for data science projects using Python and R. Modify it only if you know what you're doing! Removing patterns can lead to system files, caches, or even sensitive information being accidentally committed to your repository. Customizing for your project Need to add project-specific patterns? Look for the \"PROJECT-SPECIFIC ENTRIES\" section at the end of the file: ############################################################################# # 8 . PROJECT - SPECIFIC ENTRIES ############################################################################# # Add your project - specific entries here # For example : # models / # sandbox / # etc . This is where you can safely add patterns specific to your project without disrupting the carefully balanced patterns above. Common additions You might want to add patterns for: Large data files ( sandbox/ directory if you use it) Model checkpoints or weights ( .h5 , .pkl ) Generated figures or outputs Environment-specific configuration files ( .env , .local ) Temporary directories ( temp/ , cache/ )","title":"The .gitignore file"},{"location":"gitignore/#understanding-the-gitignore-file","text":"","title":"Understanding the .gitignore File"},{"location":"gitignore/#what-and-why","text":"The .gitignore file tells Git which files and folders to ignore when tracking changes. Think of it as keeping the party clean by not letting in the uninvited guests (like temporary files, build artifacts, and system-specific files). Our template comes with two .gitignore files: root: TEMPLATE/.gitignore crafted to work with both Python and R development workflows. It's organized into logical sections to make it easy to understand and maintain. data: TEMPLATE/data/.gitignore specifically designed to ignore files in the data directory pre-configured to ignore everything except the README.md files, to prevent users from accidentally rawdata files. Why shouldn't I commit my data files? Answer Large files bloat the repo: Every clone/download pulls the whole history, so a single 500\u202fMB dataset balloons to gigabytes after a few updates. Git is text\u2011oriented: Binary data can\u2019t be delta\u2011compressed well, so each revision is stored almost in full, slowing every operation. Privacy!: Patient or proprietary data in a public repo is dangerous and can lead to Data Use Agreements being violated. Reproducibility best practice: Keep code in Git and store immutable data elsewhere (e.g. Zenodo, FigShare) so others can fetch the exact snapshot you used AND use it across different projects. Backup strategy separation: Repos are for source; archives belong in object storage, not in version control. CI/CD efficiency: Smaller repositories mean faster pipelines and lower bandwidth costs for every contributor.","title":"What and why?"},{"location":"gitignore/#whats-inside-the-main-gitignore-file","text":"The .gitignore file is organized into these major sections: Operating System files - Keeps those pesky .DS_Store files (macOS), Thumbs.db (Windows), and other OS-specific clutter out of your repository Python related files - Ignores bytecode, package builds, and other Python-specific temporary files R related files - Skips R history, session data, and package build files IDE/Editor files - Prevents editor configs from PyCharm, VS Code, and others from being shared Dependency Management - Handles ignoring appropriate files from tools like poetry, pipenv, and pdm Build/Test artifacts - Keeps build directories and test results from cluttering your repo Documentation builds - Ignores generated documentation that should be built on-demand Project-specific entries - A section reserved for your specific project needs","title":"What's inside the main .gitignore file?"},{"location":"gitignore/#why-is-this-important","text":"A well-configured .gitignore file: Keeps your repository clean - No more accidental commits of temporary files Reduces conflicts - Prevents system-specific files from causing merge headaches Improves performance - Git works faster when it doesn't have to track thousands of irrelevant files Maintains security - Prevents accidental commits of sensitive information (like environment files) Tip If you find yourself repeatedly using git add -f to force-add ignored files, that might be a sign you need to adjust your .gitignore file. Handle with care The .gitignore file in this template has been carefully optimized for data science projects using Python and R. Modify it only if you know what you're doing! Removing patterns can lead to system files, caches, or even sensitive information being accidentally committed to your repository.","title":"Why is this important?"},{"location":"gitignore/#customizing-for-your-project","text":"Need to add project-specific patterns? Look for the \"PROJECT-SPECIFIC ENTRIES\" section at the end of the file: ############################################################################# # 8 . PROJECT - SPECIFIC ENTRIES ############################################################################# # Add your project - specific entries here # For example : # models / # sandbox / # etc . This is where you can safely add patterns specific to your project without disrupting the carefully balanced patterns above. Common additions You might want to add patterns for: Large data files ( sandbox/ directory if you use it) Model checkpoints or weights ( .h5 , .pkl ) Generated figures or outputs Environment-specific configuration files ( .env , .local ) Temporary directories ( temp/ , cache/ )","title":"Customizing for your project"},{"location":"requirements/","text":"Project Requirements This document outlines the necessary prerequisites for using the BHKLab Project Template. System Requirements Section Description 1. Git Version Requirements Git v2.28+ installation 2. Pixi Tool Requirements Pixi package manager setup 3. GitHub CLI Authentication GitHub CLI auth setup 1. Git Version Requirements You must have Git version 2.28 or higher installed on your system. This is because our template uses the --initial-branch option in the git init command. To check your Git version: git --version If your Git version is below 2.28, please update it following instructions for your operating system. 2. Pixi Tool Requirements Pixi is our preferred package manager and environment manager for this project. 2.1 Installing Pixi If you haven't installed Pixi yet: Visit the pixi documentation for installation instructions Follow the platform-specific instructions to install Pixi on your system 2.2 Verifying Installation After installation, run the following commands to verify that Pixi is properly installed: # Check pixi version pixi --version # Verify GitHub CLI is accessible through pixi pixi exec gh --help # Verify our project template tool is accessible pixi exec bhklab-project-template --help If any of these commands fail, please reinstall Pixi or make sure it's properly added to your PATH. 3. GitHub CLI Authentication Our template interacts with GitHub APIs through the GitHub CLI tool ( gh ), which requires authentication. 3.1 Logging into GitHub CLI Run the following command and follow the prompts to authenticate: pixi exec gh auth login --hostname 'github.com' --git-protocol https 3.2 Verifying Authentication To verify you're properly authenticated: pixi exec gh auth status This should show that you're logged in to GitHub. Organization Access Make sure you have been added to our lab organization(s) before proceeding with project creation! Without proper organization access, you won't be able to create repositories in our shared spaces. Troubleshooting If you encounter any issues setting up these requirements, please: Check the error messages for specific guidance Reach out to the lab's technical team if problems persist Our project template will automatically validate these requirements and provide helpful error messages if any prerequisites are not met.","title":"Requirements"},{"location":"requirements/#project-requirements","text":"This document outlines the necessary prerequisites for using the BHKLab Project Template.","title":"Project Requirements"},{"location":"requirements/#system-requirements","text":"Section Description 1. Git Version Requirements Git v2.28+ installation 2. Pixi Tool Requirements Pixi package manager setup 3. GitHub CLI Authentication GitHub CLI auth setup","title":"System Requirements"},{"location":"requirements/#1-git-version-requirements","text":"You must have Git version 2.28 or higher installed on your system. This is because our template uses the --initial-branch option in the git init command. To check your Git version: git --version If your Git version is below 2.28, please update it following instructions for your operating system.","title":"1. Git Version Requirements"},{"location":"requirements/#2-pixi-tool-requirements","text":"Pixi is our preferred package manager and environment manager for this project.","title":"2. Pixi Tool Requirements"},{"location":"requirements/#21-installing-pixi","text":"If you haven't installed Pixi yet: Visit the pixi documentation for installation instructions Follow the platform-specific instructions to install Pixi on your system","title":"2.1 Installing Pixi"},{"location":"requirements/#22-verifying-installation","text":"After installation, run the following commands to verify that Pixi is properly installed: # Check pixi version pixi --version # Verify GitHub CLI is accessible through pixi pixi exec gh --help # Verify our project template tool is accessible pixi exec bhklab-project-template --help If any of these commands fail, please reinstall Pixi or make sure it's properly added to your PATH.","title":"2.2 Verifying Installation"},{"location":"requirements/#3-github-cli-authentication","text":"Our template interacts with GitHub APIs through the GitHub CLI tool ( gh ), which requires authentication.","title":"3. GitHub CLI Authentication"},{"location":"requirements/#31-logging-into-github-cli","text":"Run the following command and follow the prompts to authenticate: pixi exec gh auth login --hostname 'github.com' --git-protocol https","title":"3.1 Logging into GitHub CLI"},{"location":"requirements/#32-verifying-authentication","text":"To verify you're properly authenticated: pixi exec gh auth status This should show that you're logged in to GitHub. Organization Access Make sure you have been added to our lab organization(s) before proceeding with project creation! Without proper organization access, you won't be able to create repositories in our shared spaces.","title":"3.2 Verifying Authentication"},{"location":"requirements/#troubleshooting","text":"If you encounter any issues setting up these requirements, please: Check the error messages for specific guidance Reach out to the lab's technical team if problems persist Our project template will automatically validate these requirements and provide helpful error messages if any prerequisites are not met.","title":"Troubleshooting"},{"location":"troubleshooting/","text":"Troubleshooting I have tried to simplify this setup as much as possible including the setup of the remote GitHub repository and the GitHub Actions workflow, and deploying the documentation to GitHub Pages. However in case you run into issues, here are some troubleshooting steps. Setting up GitHub Actions Step 1: Go to settings > Actions > General in your GitHub repository. Step 2: Select Allow all actions and reusable workflows in the Workflow permissions section + CLICK Save Step 3: Scroll down to the Workflow permissions section and select Read and write permissions AND Allow GitHub Actions to create and approve pull requests Setting up GitHub Pages Warning Before being able to deploy the documentation, you need to set up GitHub Pages. This is a one-time setup for the repository. The documentation will be deployed automatically to GitHub Pages when you push to the main branch (if the GitHub Actions workflow is set up correctly). However, you need to create a gh-pages branch in your repository. You can do this by running the following command: ``` git branch gh-pages git push origin gh-pages ``` Note: This is only possible after you have created the repository on GitHub. The template will use mkdocs to build the documentation and deploy it to GitHub Pages. To set up GitHub Pages, follow these steps: Step 1: Go to settings > Pages in your GitHub repository. Step 2: Select Deploy from a branch in the Source section. Step 3: Select gh-pages branch and / (root) folder in the Branch section. Step 4: Click Save .","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"I have tried to simplify this setup as much as possible including the setup of the remote GitHub repository and the GitHub Actions workflow, and deploying the documentation to GitHub Pages. However in case you run into issues, here are some troubleshooting steps.","title":"Troubleshooting"},{"location":"troubleshooting/#setting-up-github-actions","text":"Step 1: Go to settings > Actions > General in your GitHub repository. Step 2: Select Allow all actions and reusable workflows in the Workflow permissions section + CLICK Save Step 3: Scroll down to the Workflow permissions section and select Read and write permissions AND Allow GitHub Actions to create and approve pull requests","title":"Setting up GitHub Actions"},{"location":"troubleshooting/#setting-up-github-pages","text":"Warning Before being able to deploy the documentation, you need to set up GitHub Pages. This is a one-time setup for the repository. The documentation will be deployed automatically to GitHub Pages when you push to the main branch (if the GitHub Actions workflow is set up correctly). However, you need to create a gh-pages branch in your repository. You can do this by running the following command: ``` git branch gh-pages git push origin gh-pages ``` Note: This is only possible after you have created the repository on GitHub. The template will use mkdocs to build the documentation and deploy it to GitHub Pages. To set up GitHub Pages, follow these steps: Step 1: Go to settings > Pages in your GitHub repository. Step 2: Select Deploy from a branch in the Source section. Step 3: Select gh-pages branch and / (root) folder in the Branch section. Step 4: Click Save .","title":"Setting up GitHub Pages"},{"location":"usage/","text":"Usage Run the following command to create a new project. Replace <PROJECT_NAME> with the name of your project. using pixi pixi exec bhklab-project-template <PROJECT_NAME> i.e gdcs-drug-combo would create a directory called gdcs-drug-combo pixi exec bhklab-project-template gdcs-drug-combo This will create a new directory with the name of your project and copy the template files into it.","title":"Usage"},{"location":"usage/#usage","text":"Run the following command to create a new project. Replace <PROJECT_NAME> with the name of your project.","title":"Usage"},{"location":"usage/#using-pixi","text":"pixi exec bhklab-project-template <PROJECT_NAME> i.e gdcs-drug-combo would create a directory called gdcs-drug-combo pixi exec bhklab-project-template gdcs-drug-combo This will create a new directory with the name of your project and copy the template files into it.","title":"using pixi"}]}